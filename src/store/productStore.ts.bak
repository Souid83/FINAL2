import { create } from 'zustand';
import { supabase } from '../lib/supabase';
import type { Database } from '../types/supabase';

type Product = Database['public']['Tables']['products']['Row'] & {
  category?: {
    type: string;
    brand: string;
    model: string;
  } | null;
  stocks?: {
    id: string;
    name: string;
    quantite: number;
    group?: {
      name: string;
      synchronizable: boolean;
    };
  }[];
};

type ProductInsert = Database['public']['Tables']['products']['Insert'];

interface ProductStore {
  products: Product[];
  isLoading: boolean;
  error: string | null;
  fetchProducts: () => Promise<Product[] | null>;
  addProduct: (product: ProductInsert) => Promise<Product | null>;
  addProducts: (products: ProductInsert[]) => Promise<void>;
  updateProduct: (id: string, updates: Partial<Product>) => Promise<void>;
  deleteProduct: (id: string) => Promise<void>;
}

export const useProductStore = create<ProductStore>((set, get) => ({
  products: [],
  isLoading: false,
  error: null,

  fetchProducts: async () => {
    set({ isLoading: true, error: null });
    try {
      const { data, error } = await supabase
        .from("products")
        .select("*, category:product_categories(type, brand, model)")
        .order("created_at", { ascending: false });

      if (error) throw error;
      set({ products: data || [], isLoading: false });
      return data;
    } catch (error) {
      console.error("Error in fetchProducts:", error);
      set({
        error: error instanceof Error ? error.message : "An error occurred while fetching products",
        isLoading: false,
      });
      return null;
    }
  },

  addProduct: async (product: ProductInsert) => {
    set({ isLoading: true, error: null });
    try {
      console.log("Product received in addProduct:", product);
      
      if (!product || typeof product !== "object") {
        console.error("Received invalid product data:", product);
        return null;
      }
      if (!product.sku) {
        console.error("SKU is missing, full product data:", product);
        return null;
      }

      console.log("Checking product with SKU:", product.sku);
      
      const { data: existingProduct } = await supabase
        .from("products")
        .select("id, stock")
        .eq("sku", product.sku)
        .single();

      if (existingProduct) {
        // Mettre Ã  jour le stock et les autres informations du produit existant
        const updatedStock = existingProduct.stock + (product.stock ? parseInt(product.stock) : 0);
        const { data, error } = await supabase
          .from("products")
          .update({
            ...product,
            stock: updatedStock,
            weight_grams: product.weight_grams ? parseInt(product.weight_grams) : 0
          })
          .eq("id", existingProduct.id)
          .select("*")
          .single();

        if (error) throw error;
        
        const products = get().products.map(p => p.id === existingProduct.id ? { ...p, ...data } : p);
        set({ products, isLoading: false });
        return data;
      }

      const formattedProduct = {
        ...product,
        purchase_price_with_fees: product.purchase_price_with_fees ? parseFloat(product.purchase_price_with_fees) : 0,
        retail_price: product.retail_price ? parseFloat(product.retail_price) : 0,
        pro_price: product.pro_price ? parseFloat(product.pro_price) : 0,
        weight_grams: product.weight_grams ? parseInt(product.weight_grams) : 0,
        stock: product.stock ? parseInt(product.stock) : 0,
        stock_alert: product.stock_alert ? parseInt(product.stock_alert) : 0,
        width_cm: product.width_cm ? parseFloat(product.width_cm) : 0,
        height_cm: product.height_cm ? parseFloat(product.height_cm) : 0,
        depth_cm: product.depth_cm ? parseFloat(product.depth_cm) : 0,
      };

      const { data, error } = await supabase
        .from('products')
        .insert([formattedProduct])
        .select(`*, category:product_categories(type, brand, model)`) 
        .single();

      if (error) throw error;

      const products = get().products;
      set({ products: [data, ...products], isLoading: false });
      return data;
    } catch (error) {
      console.error('Error in addProduct:', error);
      set({ 
        error: error instanceof Error ? error.message : 'An error occurred while adding the product',
        isLoading: false 
      });
      return null;
    }
  },
}));
